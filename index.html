<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Objectiv.go</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #e0e0e0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      font-size: 14px;
      line-height: 1.4;
    }

    /* Titlebar */
    #titlebar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 32px;
      background: #0a0a0a;
      -webkit-app-region: drag;
      flex-shrink: 0;
    }

    #titlebar-title {
      padding-left: 12px;
      font-size: 12px;
      color: #666;
    }

    #window-controls {
      display: flex;
      -webkit-app-region: no-drag;
    }

    .window-btn {
      width: 46px;
      height: 32px;
      border: none;
      background: transparent;
      color: #888;
      font-family: 'Segoe MDL2 Assets', sans-serif;
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .window-btn:hover {
      background: #333;
    }

    .window-btn.close:hover {
      background: #e81123;
      color: #fff;
    }

    /* Main content wrapper */
    #content-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    /* Intro Screen */
    #intro {
      position: fixed;
      top: 32px;
      left: 0;
      width: 100%;
      height: calc(100% - 32px);
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    #intro-text {
      font-size: 0.8rem;
      color: #e0e0e0;
    }

    #intro-cursor {
      display: inline-block;
      width: 0.6em;
      height: 1em;
      background: #e0e0e0;
      margin-left: 2px;
      animation: blink 0.7s infinite;
      vertical-align: text-bottom;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* Main App */
    #app {
      display: none;
      flex-direction: column;
      width: 100%;
      max-width: 500px;
      padding: 1rem;
      padding-bottom: 60px;
    }

    /* Header */
    #header {
      padding: 8px 12px;
      cursor: pointer;
    }

    #header:hover {
      background: #1a1a1a;
    }

    #header-title {
      font-weight: bold;
      color: #fff;
    }

    #header-clarity {
      color: #666;
      font-size: 12px;
      margin-top: 2px;
    }

    .clarity-fuzzy {
      color: #ff8855;
    }

    .clarity-forming {
      color: #ffcc55;
    }

    .clarity-clear {
      color: #55ff88;
    }

    #header-description {
      color: #888;
      margin-top: 4px;
    }

    /* List Container */
    #list-container {
      overflow-y: auto;
      padding: 0 12px;
      margin: 0.5rem 0;
    }

    /* Section subheaders */
    .section-header {
      color: #555;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 8px 8px 4px 8px;
      margin-top: 8px;
    }

    .section-header:first-child {
      margin-top: 0;
    }

    .list-item {
      padding: 2px 8px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
    }

    .list-item-text {
      flex: 1;
      word-wrap: break-word;
    }

    .list-item:hover,
    .list-item.selected {
      background: #1a1a1a;
    }

    .clarity {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
      padding-right: 8px;
      white-space: nowrap;
      min-width: 90px;
    }

    .clarity-score {
      color: #888;
      font-size: 12px;
      min-width: 35px;
      text-align: right;
    }

    .clarity-badge {
      font-size: 10px;
      padding: 1px 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .edit-btn {
      display: none;
      color: #0891b2;
      font-size: 11px;
      padding: 1px 8px;
      cursor: pointer;
    }

    .edit-btn:hover {
      color: #fff;
    }

    .list-item:hover .clarity-score,
    .list-item:hover .clarity-badge {
      display: none;
    }

    .list-item:hover .edit-btn {
      display: block;
    }

    .step-timestamp {
      color: #666;
      font-size: 12px;
    }

    .add-option {
      color: #0891b2;
      padding: 2px 8px;
      cursor: pointer;
    }

    .add-option:hover,
    .add-option.selected {
      background: #1a1a1a;
    }

    .add-option.disabled {
      color: #555;
      cursor: default;
    }

    .add-option.disabled:hover {
      background: transparent;
    }

    /* Inline prompt row */
    .prompt-row {
      padding: 2px 8px;
      background: #000;
      border: 1px solid #0891b2;
    }

    .prompt-label {
      color: #0891b2;
      font-size: 12px;
      margin-bottom: 2px;
    }

    .prompt-input-wrap {
      display: flex;
      align-items: center;
    }

    .prompt-prefix {
      color: #0891b2;
      margin-right: 4px;
    }

    .prompt-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #e0e0e0;
      font-family: inherit;
      font-size: inherit;
      outline: none;
      caret-color: #e0e0e0;
      padding: 0;
    }

    /* Confirm row */
    .confirm-row {
      padding: 2px 8px;
      background: #000;
      border: 1px solid #ffff55;
    }

    .confirm-text {
      color: #ffff55;
    }

    .confirm-hint {
      color: #888;
      font-size: 12px;
    }

    /* Status Bar */
    #status-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 8px 12px;
      color: #888;
      background: #000;
      border-top: 1px solid #333;
    }

    #shortcuts {
      color: #666;
      font-size: 13px;
    }

    /* Message toast */
    #message-toast {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background: #1a1a1a;
      border: 1px solid #55ff55;
      color: #55ff55;
      padding: 8px 16px;
      display: none;
      z-index: 100;
    }

    .hidden {
      display: none !important;
    }

    .empty-hint {
      color: #444;
      font-style: italic;
      padding: 2px 8px;
    }
  </style>
</head>
<body>
  <!-- Titlebar -->
  <div id="titlebar">
    <div id="titlebar-title">Objectiv.go</div>
    <div id="window-controls">
      <button class="window-btn" id="btn-minimize">&#xE921;</button>
      <button class="window-btn" id="btn-maximize">&#xE922;</button>
      <button class="window-btn close" id="btn-close">&#xE8BB;</button>
    </div>
  </div>

  <!-- Content Wrapper -->
  <div id="content-wrapper">
    <!-- Intro Screen -->
    <div id="intro">
      <div style="text-align: center;">
        <div><span id="intro-text"></span><span id="intro-cursor"></span></div>
        <div id="intro-tagline" style="color: #e0e0e0; font-size: 0.8rem; margin-top: 8px; opacity: 0;"></div>
      </div>
    </div>

    <!-- Main App -->
    <div id="app">
    <div id="header" onclick="handleHeaderClick()">
      <div id="header-title">OBJECTIVES</div>
      <div id="header-clarity"></div>
      <div id="header-description"></div>
    </div>

    <div id="list-container"></div>

    <div id="status-bar">
      <div id="shortcuts">[â†‘â†“] Navigate  [Enter] Select  [a] Add  [r] Refine  [d] Delete  [Esc] Back</div>
    </div>
  </div>

    <!-- Message Toast -->
    <div id="message-toast"></div>
  </div>

  <script>
    // Window controls (Electron)
    if (window.electronAPI) {
      document.getElementById('btn-minimize').addEventListener('click', () => window.electronAPI.minimize());
      document.getElementById('btn-maximize').addEventListener('click', () => window.electronAPI.maximize());
      document.getElementById('btn-close').addEventListener('click', () => window.electronAPI.close());
    }
  </script>

  <script>
    // Data
    const STORAGE_KEY = 'life-data';
    let data = loadData();

    // Navigation state
    let navigationStack = [];
    let currentView = {
      level: 'objectives',  // 'objectives' or 'objective-detail'
      parent: null
    };
    let selectedIndex = -1;  // -1 = no selection
    let keyboardMode = false; // Only show selection when using keyboard
    let selectedSection = 'priorities'; // 'priorities' or 'steps' (for objective-detail view)

    // Prompt state
    let promptMode = null; // null, 'add', 'edit', 'refine', 'log', 'confirm'
    let promptStep = 0;
    let promptData = {};
    let promptTargetIndex = -1;
    let promptTargetSection = null;

    // Load data from localStorage
    function loadData() {
      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          const parsed = JSON.parse(stored);
          // Migrate from old format if needed
          if (parsed.outcomes && !parsed.objectives) {
            return migrateData(parsed);
          }
          // Ensure new structure
          if (parsed.objectives) {
            for (const obj of parsed.objectives) {
              if (!obj.priorities) obj.priorities = [];
              if (!obj.steps) obj.steps = [];
            }
          }
          return parsed;
        }
      } catch (e) {}
      return { objectives: [] };
    }

    // Migrate from old hierarchy
    function migrateData(oldData) {
      const newObjectives = [];
      for (const outcome of (oldData.outcomes || [])) {
        for (const objective of (outcome.objectives || [])) {
          // Collect all priorities and steps
          const allPriorities = [];
          const allSteps = [];

          for (const priority of (objective.priorities || [])) {
            allPriorities.push({
              id: priority.id,
              name: priority.name,
              description: priority.description || ''
            });
            for (const step of (priority.steps || [])) {
              allSteps.push({
                id: step.id,
                name: step.name,
                loggedAt: step.done ? new Date().toISOString() : new Date().toISOString()
              });
            }
          }

          newObjectives.push({
            id: objective.id,
            name: objective.name,
            description: objective.description || '',
            priorities: allPriorities,
            steps: allSteps
          });
        }
      }
      return { objectives: newObjectives };
    }

    // Save data to localStorage
    function saveData() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }

    // Generate unique ID
    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
    }

    // Format timestamp for display
    // Shows: "Jan 9 2:34pm" (current year) or "Jan 9 2025 2:34pm" (other years)
    function formatTimestamp(isoString) {
      if (!isoString) return '';
      const date = new Date(isoString);
      const now = new Date();
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

      const month = months[date.getMonth()];
      const day = date.getDate();

      // Format time as 12-hour with am/pm
      let hours = date.getHours();
      const minutes = date.getMinutes();
      const ampm = hours >= 12 ? 'pm' : 'am';
      hours = hours % 12;
      if (hours === 0) hours = 12;
      const timeStr = minutes === 0
        ? `${hours}${ampm}`
        : `${hours}:${minutes.toString().padStart(2, '0')}${ampm}`;

      // Include year only if different from current year
      if (date.getFullYear() !== now.getFullYear()) {
        return `${month} ${day} ${date.getFullYear()} ${timeStr}`;
      }
      return `${month} ${day} ${timeStr}`;
    }

    // Calculate clarity level - uses cached LLM score or falls back to word count
    function calculateClarity(item) {
      // Use cached LLM score if available
      if (item.clarityScore !== undefined && item.clarityScore !== null) {
        const score = item.clarityScore;
        return score <= 30 ? 'fuzzy' : score <= 60 ? 'forming' : 'clear';
      }

      // Fallback to word count
      const desc = item.description || '';
      const wordCount = desc.trim().split(/\s+/).filter(w => w).length;
      if (wordCount === 0) return 'fuzzy';
      if (wordCount < 10) return 'forming';
      return 'clear';
    }

    // Get clarity display HTML with score, badge, and edit button
    // Fuzzy = lighter grey (stands out), Clear = fades to background
    // Edit button appears on hover (via CSS)
    function getClarityDisplay(item, section = 'objectives', index = 0) {
      const clarity = calculateClarity(item);

      if (item._clarityLoading) {
        return '<span class="clarity-score">...</span><span class="edit-btn" data-section="' + section + '" data-index="' + index + '">edit</span>';
      }

      let score = item.clarityScore;
      let scoreText;

      if (score !== undefined && score !== null) {
        scoreText = `${score}%`;
      } else {
        // Fallback score based on word count clarity
        score = clarity === 'fuzzy' ? 15 : clarity === 'forming' ? 45 : 75;
        scoreText = 'â€”';
      }

      return `<span class="clarity-score">${scoreText}</span><span class="clarity-badge">${clarity}</span><span class="edit-btn" data-section="${section}" data-index="${index}">edit</span>`;
    }

    // Pending clarity requests (to batch updates)
    let clarityQueue = [];
    let clarityProcessing = false;

    // Request LLM clarity calculation for an item (queued to prevent flicker)
    function refreshClarity(item) {
      // Don't refresh during prompts (editing/adding) to avoid disruption
      if (promptMode) {
        console.log('â¸ï¸ Skipping clarity (prompt mode):', item.name);
        return;
      }

      if (!item.name || !item.name.trim()) {
        item.clarityScore = 0;
        return;
      }

      // Check if we already have a score for this exact name+description combo
      const cacheKey = `${item.name}|${item.description || ''}`;
      if (item._clarityKey === cacheKey && item.clarityScore !== undefined) {
        console.log('âœ“ Already scored:', item.name, item.clarityScore + '%');
        return; // Already calculated for this content
      }

      // Don't queue duplicates
      if (item._clarityQueued || item._clarityLoading) {
        console.log('â³ Already queued/loading:', item.name);
        return;
      }

      console.log('ðŸ“¥ Queuing for clarity:', item.name);
      item._clarityQueued = true;
      clarityQueue.push(item);

      // Process queue after a short delay (batch multiple items)
      if (!clarityProcessing) {
        clarityProcessing = true;
        setTimeout(processClarityQueue, 100);
      }
    }

    async function processClarityQueue() {
      while (clarityQueue.length > 0) {
        const item = clarityQueue.shift();
        item._clarityQueued = false;

        const cacheKey = `${item.name}|${item.description || ''}`;
        if (item._clarityKey === cacheKey && item.clarityScore !== undefined) {
          continue; // Already done
        }

        try {
          item._clarityLoading = true;
          console.log('ðŸ¤– Requesting clarity for:', item.name);

          const result = await window.electronAPI.calculateClarity(item.name, item.description || '');
          item._clarityLoading = false;

          if (result.error) {
            console.log('âŒ Clarity error:', result.error);
          } else if (result.score !== null) {
            console.log('âœ… Clarity score:', result.score + '%');
            item.clarityScore = result.score;
            item._clarityKey = cacheKey;
            saveData();
          }
        } catch (err) {
          item._clarityLoading = false;
          console.log('âŒ Clarity API unavailable:', err.message);
        }
      }

      clarityProcessing = false;
      // Only update if not in prompt mode (avoid disrupting edits)
      if (!promptMode) {
        updateList();
      }
    }

    // Refresh clarity for all items that need it
    async function refreshAllClarity() {
      const items = [...data.objectives];
      data.objectives.forEach(obj => {
        if (obj.priorities) items.push(...obj.priorities);
      });

      for (const item of items) {
        const cacheKey = `${item.name}|${item.description || ''}`;
        if (item._clarityKey !== cacheKey) {
          await refreshClarity(item);
        }
      }
    }

    // Capitalize first letter
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    // Show intro animation
    async function showIntro() {
      let tagline = 'Proceed.';
      try {
        const response = await fetch('taglines.json');
        const taglines = await response.json();
        tagline = taglines[Math.floor(Math.random() * taglines.length)];
      } catch (e) {}

      const introText = document.getElementById('intro-text');
      const introTagline = document.getElementById('intro-tagline');
      const introCursor = document.getElementById('intro-cursor');

      await typeText(introText, 'Objectiv.go', 80);
      await new Promise(r => setTimeout(r, 300));
      introTagline.style.opacity = '1';
      introTagline.appendChild(introCursor);
      await typeText(introTagline, tagline, 80, introCursor);
      await new Promise(r => setTimeout(r, 1500));

      document.getElementById('intro').style.display = 'none';
      document.getElementById('app').style.display = 'flex';
    }

    function typeText(element, text, speed, cursorEl = null) {
      return new Promise((resolve) => {
        let i = 0;
        const interval = setInterval(() => {
          if (i <= text.length) {
            if (cursorEl) {
              element.textContent = text.slice(0, i);
              element.appendChild(cursorEl);
            } else {
              element.textContent = text.slice(0, i);
            }
            i++;
          } else {
            clearInterval(interval);
            resolve();
          }
        }, speed);
      });
    }

    // Update header display
    function updateHeader() {
      const { level, parent } = currentView;
      const titleEl = document.getElementById('header-title');
      const clarityEl = document.getElementById('header-clarity');
      const descEl = document.getElementById('header-description');

      if (level === 'objectives') {
        titleEl.textContent = 'OBJECTIVES';
        clarityEl.textContent = '';
        clarityEl.className = '';
        descEl.textContent = '';
      } else if (parent) {
        titleEl.textContent = parent.name;
        const clarity = calculateClarity(parent);
        clarityEl.textContent = getClarityDisplay(parent);
        clarityEl.className = `clarity-${clarity}`;
        descEl.textContent = parent.description ? `"${parent.description}"` : '';
        // Trigger async clarity refresh if needed
        refreshClarity(parent);
      }
    }

    // Get total selectable items in current view
    function getTotalSelectableItems() {
      if (currentView.level === 'objectives') {
        return data.objectives.length;
      } else {
        const obj = currentView.parent;
        // priorities + add-priority + steps + add-step
        return obj.priorities.length + 1 + obj.steps.length + 1;
      }
    }

    // Get what's selected (for objective-detail view)
    function getSelectionInfo() {
      if (currentView.level === 'objectives') {
        return { section: 'objectives', index: selectedIndex };
      }

      const obj = currentView.parent;
      const prioritiesCount = obj.priorities.length;
      const stepsCount = obj.steps.length;

      // Layout: priorities (0..n-1), add-priority (n), steps (n+1..n+1+m-1), add-step (n+1+m)
      // Note: Steps are displayed newest-first (reversed), so we convert display index to array index
      if (selectedIndex <= prioritiesCount) {
        if (selectedIndex === prioritiesCount) {
          return { section: 'priorities', index: -1, isAdd: true };
        }
        return { section: 'priorities', index: selectedIndex };
      } else {
        const stepsStartIndex = prioritiesCount + 1;
        const displayIndex = selectedIndex - stepsStartIndex;
        if (displayIndex >= stepsCount) {
          return { section: 'steps', index: -1, isAdd: true };
        }
        // Convert display index (0 = newest at top) to array index (0 = oldest)
        const actualIndex = stepsCount - 1 - displayIndex;
        return { section: 'steps', index: actualIndex };
      }
    }

    // Create inline prompt HTML
    function createPromptRow(label, defaultValue = '') {
      return `
        <div class="prompt-row">
          <div class="prompt-label">${label}</div>
          <div class="prompt-input-wrap">
            <span class="prompt-prefix">&gt;</span>
            <input type="text" class="prompt-input" value="${defaultValue.replace(/"/g, '&quot;')}" autocomplete="off" spellcheck="false">
          </div>
        </div>
      `;
    }

    // Create confirm row HTML
    function createConfirmRow(text) {
      return `
        <div class="confirm-row">
          <div class="confirm-text">${text}</div>
          <div class="confirm-hint">[y] Yes  [n] No  [Esc] Cancel</div>
        </div>
      `;
    }

    // Update list display
    function updateList() {
      const container = document.getElementById('list-container');
      container.innerHTML = '';

      if (currentView.level === 'objectives') {
        renderObjectivesList(container);
      } else {
        renderObjectiveDetail(container);
      }

      // Focus input if prompt is active
      if (promptMode) {
        setTimeout(() => {
          const input = container.querySelector('.prompt-input');
          if (input) {
            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);
          }
        }, 0);
      }
    }

    // Render objectives list (top level)
    function renderObjectivesList(container) {
      data.objectives.forEach((obj, index) => {
        if (promptMode === 'edit' && promptTargetIndex === index) {
          const div = document.createElement('div');
          div.innerHTML = createPromptRow(getPromptLabel(), getPromptDefault());
          container.appendChild(div.firstElementChild);
          return;
        }

        if (promptMode === 'refine' && promptTargetIndex === index) {
          const div = document.createElement('div');
          div.innerHTML = createPromptRow('Refine description:', obj.description || '');
          container.appendChild(div.firstElementChild);
          return;
        }

        if (promptMode === 'confirm' && promptTargetIndex === index) {
          const div = document.createElement('div');
          div.innerHTML = createConfirmRow(`Delete "${obj.name}"?`);
          container.appendChild(div.firstElementChild);
          return;
        }

        const div = document.createElement('div');
        div.className = 'list-item' + (keyboardMode && index === selectedIndex && !promptMode ? ' selected' : '');
        div.onclick = () => { keyboardMode = false; handleSelect(index); };

        const clarity = calculateClarity(obj);
        div.innerHTML = `<span class="list-item-text">${index + 1}. ${obj.name}</span><span class="clarity">${getClarityDisplay(obj, 'objectives', index)}</span>`;
        container.appendChild(div);
        // Trigger async clarity refresh
        refreshClarity(obj);
      });

      // Add new objective option
      if (promptMode === 'add' && promptTargetSection === 'objectives') {
        const div = document.createElement('div');
        div.innerHTML = createPromptRow(getPromptLabel(), '');
        container.appendChild(div.firstElementChild);
      } else if (data.objectives.length < 3) {
        const addDiv = document.createElement('div');
        addDiv.className = 'add-option';
        addDiv.innerHTML = '+ Add new objective';
        addDiv.onclick = () => startAddObjective();
        container.appendChild(addDiv);
      } else {
        const addDiv = document.createElement('div');
        addDiv.className = 'add-option disabled';
        addDiv.innerHTML = '(max 3 reached)';
        container.appendChild(addDiv);
      }
    }

    // Render objective detail (priorities + steps)
    function renderObjectiveDetail(container) {
      const obj = currentView.parent;
      let globalIndex = 0;

      // PRIORITIES section
      const prioritiesHeader = document.createElement('div');
      prioritiesHeader.className = 'section-header';
      prioritiesHeader.textContent = 'PRIORITIES';
      container.appendChild(prioritiesHeader);

      if (obj.priorities.length === 0 && !(promptMode === 'add' && promptTargetSection === 'priorities')) {
        const empty = document.createElement('div');
        empty.className = 'empty-hint';
        empty.textContent = 'no priorities yet';
        container.appendChild(empty);
      }

      obj.priorities.forEach((priority, index) => {
        const currentGlobalIndex = globalIndex;

        if (promptMode === 'edit' && promptTargetSection === 'priorities' && promptTargetIndex === index) {
          const div = document.createElement('div');
          div.innerHTML = createPromptRow(getPromptLabel(), getPromptDefault());
          container.appendChild(div.firstElementChild);
          globalIndex++;
          return;
        }

        if (promptMode === 'refine' && promptTargetSection === 'priorities' && promptTargetIndex === index) {
          const div = document.createElement('div');
          div.innerHTML = createPromptRow('Refine description:', priority.description || '');
          container.appendChild(div.firstElementChild);
          globalIndex++;
          return;
        }

        if (promptMode === 'confirm' && promptTargetSection === 'priorities' && promptTargetIndex === index) {
          const div = document.createElement('div');
          div.innerHTML = createConfirmRow(`Delete "${priority.name}"?`);
          container.appendChild(div.firstElementChild);
          globalIndex++;
          return;
        }

        const div = document.createElement('div');
        div.className = 'list-item' + (keyboardMode && currentGlobalIndex === selectedIndex && !promptMode ? ' selected' : '');
        div.onclick = () => { keyboardMode = false; updateList(); };

        const clarity = calculateClarity(priority);
        div.innerHTML = `<span class="list-item-text">- ${priority.name}</span><span class="clarity">${getClarityDisplay(priority, 'priorities', index)}</span>`;
        container.appendChild(div);
        globalIndex++;
        // Trigger async clarity refresh
        refreshClarity(priority);
      });

      // Add priority option
      const addPriorityIndex = globalIndex;
      if (promptMode === 'add' && promptTargetSection === 'priorities') {
        const div = document.createElement('div');
        div.innerHTML = createPromptRow('Priority name:', '');
        container.appendChild(div.firstElementChild);
      } else if (obj.priorities.length < 3) {
        const addDiv = document.createElement('div');
        addDiv.className = 'add-option' + (keyboardMode && addPriorityIndex === selectedIndex && !promptMode ? ' selected' : '');
        addDiv.innerHTML = '+ Add priority';
        addDiv.onclick = () => { keyboardMode = false; startAddPriority(); };
        container.appendChild(addDiv);
      } else {
        const addDiv = document.createElement('div');
        addDiv.className = 'add-option disabled';
        addDiv.innerHTML = '(max 3 priorities)';
        container.appendChild(addDiv);
      }
      globalIndex++;

      // STEPS section
      const stepsHeader = document.createElement('div');
      stepsHeader.className = 'section-header';
      stepsHeader.textContent = 'STEPS';
      container.appendChild(stepsHeader);

      if (obj.steps.length === 0 && !(promptMode === 'log' && promptTargetSection === 'steps')) {
        const empty = document.createElement('div');
        empty.className = 'empty-hint';
        empty.textContent = 'no steps logged yet';
        container.appendChild(empty);
      }

      // Display steps newest-first (reverse chronological)
      // We iterate from the end of the array to the beginning
      for (let displayIdx = 0; displayIdx < obj.steps.length; displayIdx++) {
        // Map display index to actual array index (reversed)
        const actualIdx = obj.steps.length - 1 - displayIdx;
        const step = obj.steps[actualIdx];
        const currentGlobalIndex = globalIndex;

        if (promptMode === 'edit' && promptTargetSection === 'steps' && promptTargetIndex === actualIdx) {
          const div = document.createElement('div');
          div.innerHTML = createPromptRow('Step:', step.name);
          container.appendChild(div.firstElementChild);
          globalIndex++;
          continue;
        }

        if (promptMode === 'confirm' && promptTargetSection === 'steps' && promptTargetIndex === actualIdx) {
          const div = document.createElement('div');
          div.innerHTML = createConfirmRow(`Delete "${step.name}"?`);
          container.appendChild(div.firstElementChild);
          globalIndex++;
          continue;
        }

        const div = document.createElement('div');
        div.className = 'list-item' + (keyboardMode && currentGlobalIndex === selectedIndex && !promptMode ? ' selected' : '');
        div.onclick = () => { keyboardMode = false; updateList(); };

        const timestamp = formatTimestamp(step.loggedAt);
        const orderNum = step.orderNumber || (actualIdx + 1); // Fallback for legacy steps
        div.innerHTML = `<span class="step-timestamp">#${orderNum} ${timestamp}</span> ${step.name}`;
        container.appendChild(div);
        globalIndex++;
      }

      // Add step option (no limit)
      const addStepIndex = globalIndex;
      if (promptMode === 'log' && promptTargetSection === 'steps') {
        const div = document.createElement('div');
        div.innerHTML = createPromptRow('What did you do?', '');
        container.appendChild(div.firstElementChild);
      } else {
        const addDiv = document.createElement('div');
        addDiv.className = 'add-option' + (keyboardMode && addStepIndex === selectedIndex && !promptMode ? ' selected' : '');
        addDiv.innerHTML = '+ Log a step';
        addDiv.onclick = () => { keyboardMode = false; startLogStep(); };
        container.appendChild(addDiv);
      }
    }

    // Get prompt label
    function getPromptLabel() {
      if (promptMode === 'add') {
        if (promptStep === 0) return `${capitalize(promptData.type)} name:`;
        if (promptStep === 1) return 'Description (optional):';
      } else if (promptMode === 'edit') {
        if (promptStep === 0) return 'Name:';
        if (promptStep === 1) return 'Description:';
      }
      return '';
    }

    // Get prompt default
    function getPromptDefault() {
      if (promptMode === 'edit' && promptData.item) {
        if (promptStep === 0) return promptData.item.name;
        if (promptStep === 1) return promptData.item.description || '';
      }
      return '';
    }

    // Update status bar
    function updateStatusBar() {
      let shortcuts = '';
      if (promptMode) {
        shortcuts = '[Enter] Confirm  [Esc] Cancel';
      } else if (currentView.level === 'objectives') {
        shortcuts = '[â†‘â†“] Navigate  [Enter] Select  [a] Add  [e] Edit  [r] Refine  [d] Delete  [q] Quit';
      } else {
        const sel = getSelectionInfo();
        if (sel.isAdd) {
          shortcuts = '[â†‘â†“] Navigate  [Enter] Add  [Esc] Back';
        } else if (sel.section === 'priorities') {
          shortcuts = '[â†‘â†“] Navigate  [a] Add  [e] Edit  [r] Refine  [d] Delete  [Esc] Back';
        } else {
          shortcuts = '[â†‘â†“] Navigate  [s] Log step  [e] Edit  [d] Delete  [Esc] Back';
        }
      }
      document.getElementById('shortcuts').textContent = shortcuts;
    }

    // Show message toast
    function showMessage(text, duration = 1500) {
      const toast = document.getElementById('message-toast');
      toast.textContent = text;
      toast.style.display = 'block';
      setTimeout(() => { toast.style.display = 'none'; }, duration);
    }

    // Handle header click
    function handleHeaderClick() {
      if (promptMode) return;
      handleBack();
    }

    // Handle item selection (Enter or click)
    function handleSelect(clickIndex) {
      // Use clicked index if provided, otherwise use keyboard selectedIndex
      const idx = clickIndex !== undefined ? clickIndex : selectedIndex;

      if (currentView.level === 'objectives') {
        if (idx >= 0 && idx < data.objectives.length) {
          showObjectiveDetail(data.objectives[idx]);
        }
      } else {
        // For clicks in detail view, temporarily set selectedIndex to get correct selection info
        if (clickIndex !== undefined) selectedIndex = clickIndex;
        const sel = getSelectionInfo();
        if (sel.isAdd) {
          if (sel.section === 'priorities') {
            startAddPriority();
          } else {
            startLogStep();
          }
        }
      }
      updateList();
    }

    // Show objectives list (top level)
    function showObjectives() {
      currentView = { level: 'objectives', parent: null };
      navigationStack = [];
      selectedIndex = 0;
      refreshView();
    }

    // Show objective detail
    function showObjectiveDetail(objective) {
      navigationStack.push({ ...currentView, selectedIndex });
      currentView = { level: 'objective-detail', parent: objective };
      selectedIndex = 0;
      refreshView();
    }

    // Handle back navigation
    function handleBack() {
      if (navigationStack.length === 0) return;
      const prev = navigationStack.pop();
      currentView = prev;
      selectedIndex = prev.selectedIndex || 0;
      refreshView();
    }

    // Refresh current view
    function refreshView() {
      updateHeader();
      updateList();
      updateStatusBar();
    }

    // Start add objective
    function startAddObjective() {
      if (data.objectives.length >= 3) return;
      promptMode = 'add';
      promptStep = 0;
      promptTargetIndex = data.objectives.length;
      promptTargetSection = 'objectives';
      promptData = { type: 'objective' };
      updateList();
      updateStatusBar();
    }

    // Start add priority
    function startAddPriority() {
      const obj = currentView.parent;
      if (obj.priorities.length >= 3) return;
      promptMode = 'add';
      promptStep = 0;
      promptTargetIndex = obj.priorities.length;
      promptTargetSection = 'priorities';
      promptData = { type: 'priority' };
      updateList();
      updateStatusBar();
    }

    // Start log step
    function startLogStep() {
      promptMode = 'log';
      promptStep = 0;
      promptTargetSection = 'steps';
      promptData = {};
      updateList();
      updateStatusBar();
    }

    // Start edit
    function startEdit() {
      if (currentView.level === 'objectives') {
        if (selectedIndex >= data.objectives.length) return;
        promptMode = 'edit';
        promptStep = 0;
        promptTargetIndex = selectedIndex;
        promptTargetSection = 'objectives';
        promptData = { type: 'objective', item: data.objectives[selectedIndex] };
      } else {
        const sel = getSelectionInfo();
        if (sel.isAdd) return;
        const obj = currentView.parent;
        if (sel.section === 'priorities') {
          promptMode = 'edit';
          promptStep = 0;
          promptTargetIndex = sel.index;
          promptTargetSection = 'priorities';
          promptData = { type: 'priority', item: obj.priorities[sel.index] };
        } else {
          promptMode = 'edit';
          promptStep = 0;
          promptTargetIndex = sel.index;
          promptTargetSection = 'steps';
          promptData = { type: 'step', item: obj.steps[sel.index] };
        }
      }
      updateList();
      updateStatusBar();
    }

    // Start refine
    function startRefine() {
      if (currentView.level === 'objectives') {
        if (selectedIndex >= data.objectives.length) return;
        promptMode = 'refine';
        promptTargetIndex = selectedIndex;
        promptTargetSection = 'objectives';
        promptData = { item: data.objectives[selectedIndex] };
      } else {
        const sel = getSelectionInfo();
        if (sel.isAdd || sel.section === 'steps') return;
        const obj = currentView.parent;
        promptMode = 'refine';
        promptTargetIndex = sel.index;
        promptTargetSection = 'priorities';
        promptData = { item: obj.priorities[sel.index] };
      }
      updateList();
      updateStatusBar();
    }

    // Start delete
    function startDelete() {
      if (currentView.level === 'objectives') {
        if (selectedIndex >= data.objectives.length) return;
        promptMode = 'confirm';
        promptTargetIndex = selectedIndex;
        promptTargetSection = 'objectives';
        promptData = { action: 'delete', item: data.objectives[selectedIndex] };
      } else {
        const sel = getSelectionInfo();
        if (sel.isAdd) return;
        const obj = currentView.parent;
        if (sel.section === 'priorities') {
          promptMode = 'confirm';
          promptTargetIndex = sel.index;
          promptTargetSection = 'priorities';
          promptData = { action: 'delete', item: obj.priorities[sel.index] };
        } else {
          promptMode = 'confirm';
          promptTargetIndex = sel.index;
          promptTargetSection = 'steps';
          promptData = { action: 'delete', item: obj.steps[sel.index] };
        }
      }
      updateList();
      updateStatusBar();
    }

    // Process prompt input
    function processPromptInput(value) {
      if (promptMode === 'add') {
        processAddStep(value);
      } else if (promptMode === 'edit') {
        processEditStep(value);
      } else if (promptMode === 'refine') {
        processRefineStep(value);
      } else if (promptMode === 'log') {
        processLogStepInput(value);
      }
    }

    // Process add
    function processAddStep(value) {
      if (promptStep === 0) {
        if (!value.trim()) {
          showMessage('Name is required');
          updateList();
          return;
        }
        promptData.name = value.trim();
        promptStep = 1;
        updateList();
      } else if (promptStep === 1) {
        promptData.description = value.trim();
        finishAdd();
      }
    }

    // Finish add
    function finishAdd() {
      const newItem = {
        id: generateId(),
        name: promptData.name,
        description: promptData.description || ''
      };

      if (promptData.type === 'objective') {
        newItem.priorities = [];
        newItem.steps = [];
        data.objectives.push(newItem);
      } else if (promptData.type === 'priority') {
        currentView.parent.priorities.push(newItem);
      }

      saveData();
      cancelPrompt();
    }

    // Process log step
    function processLogStepInput(value) {
      if (!value.trim()) {
        showMessage('Enter what you did');
        updateList();
        return;
      }

      // Calculate next order number (max existing + 1, or 1 if no steps)
      const steps = currentView.parent.steps;
      const maxOrder = steps.reduce((max, s) => Math.max(max, s.orderNumber || 0), 0);

      const newStep = {
        id: generateId(),
        name: value.trim(),
        loggedAt: new Date().toISOString(),
        orderNumber: maxOrder + 1
      };

      currentView.parent.steps.push(newStep);
      saveData();
      cancelPrompt();
    }

    // Process edit
    function processEditStep(value) {
      if (promptStep === 0) {
        if (!value.trim()) {
          showMessage('Name is required');
          updateList();
          return;
        }
        promptData.newName = value.trim();
        if (promptData.type === 'step') {
          finishEdit();
        } else {
          promptStep = 1;
          updateList();
        }
      } else if (promptStep === 1) {
        promptData.newDescription = value.trim();
        finishEdit();
      }
    }

    // Finish edit
    function finishEdit() {
      promptData.item.name = promptData.newName;
      if (promptData.type !== 'step') {
        promptData.item.description = promptData.newDescription || '';
      }
      saveData();
      cancelPrompt();
    }

    // Process refine
    function processRefineStep(value) {
      promptData.item.description = value.trim();
      saveData();
      cancelPrompt();
    }

    // Process confirm
    function processConfirm(confirmed) {
      if (confirmed && promptData.action === 'delete') {
        if (promptTargetSection === 'objectives') {
          data.objectives.splice(promptTargetIndex, 1);
          selectedIndex = Math.min(selectedIndex, data.objectives.length - 1);
          if (selectedIndex < 0) selectedIndex = 0;
        } else if (promptTargetSection === 'priorities') {
          currentView.parent.priorities.splice(promptTargetIndex, 1);
        } else if (promptTargetSection === 'steps') {
          currentView.parent.steps.splice(promptTargetIndex, 1);
        }
        saveData();
      }
      cancelPrompt();
    }

    // Cancel prompt
    function cancelPrompt() {
      promptMode = null;
      promptStep = 0;
      promptData = {};
      promptTargetIndex = -1;
      promptTargetSection = null;
      refreshView();
    }

    // Keyboard handling
    document.addEventListener('keydown', (e) => {
      // Handle prompt input
      if (promptMode === 'add' || promptMode === 'edit' || promptMode === 'refine' || promptMode === 'log') {
        if (e.key === 'Escape') {
          e.preventDefault();
          cancelPrompt();
          return;
        }
        if (e.key === 'Enter') {
          e.preventDefault();
          const input = document.querySelector('.prompt-input');
          if (input) processPromptInput(input.value);
          return;
        }
        return;
      }

      // Handle confirm
      if (promptMode === 'confirm') {
        if (e.key === 'y' || e.key === 'Y') {
          e.preventDefault();
          processConfirm(true);
          return;
        }
        if (e.key === 'n' || e.key === 'N' || e.key === 'Escape') {
          e.preventDefault();
          processConfirm(false);
          return;
        }
        return;
      }

      // Calculate max index for navigation
      let maxIndex;
      if (currentView.level === 'objectives') {
        maxIndex = data.objectives.length - 1;
      } else {
        const obj = currentView.parent;
        // priorities + add-priority + steps + add-step
        maxIndex = obj.priorities.length + 1 + obj.steps.length;
      }

      switch (e.key) {
        case 'ArrowUp':
        case 'k':
          e.preventDefault();
          keyboardMode = true;
          if (selectedIndex < 0) selectedIndex = 0;
          else if (selectedIndex > 0) selectedIndex--;
          updateList();
          updateStatusBar();
          break;

        case 'ArrowDown':
        case 'j':
          e.preventDefault();
          keyboardMode = true;
          if (selectedIndex < 0) selectedIndex = 0;
          else if (selectedIndex < maxIndex) selectedIndex++;
          updateList();
          updateStatusBar();
          break;

        case 'Enter':
          e.preventDefault();
          if (keyboardMode && selectedIndex >= 0) handleSelect();
          break;

        case 'a':
          e.preventDefault();
          if (currentView.level === 'objectives') {
            startAddObjective();
          } else {
            const sel = getSelectionInfo();
            if (sel.section === 'priorities' || sel.isAdd && sel.section === 'priorities') {
              startAddPriority();
            }
          }
          break;

        case 's':
          e.preventDefault();
          if (currentView.level === 'objective-detail') {
            startLogStep();
          }
          break;

        case 'e':
          e.preventDefault();
          startEdit();
          break;

        case 'r':
          e.preventDefault();
          startRefine();
          break;

        case 'd':
          e.preventDefault();
          startDelete();
          break;

        case 'Escape':
        case 'Backspace':
        case 'b':
          e.preventDefault();
          handleBack();
          break;

        case 'q':
          if (currentView.level === 'objectives') {
            showMessage('session ended.');
          }
          break;
      }
    });

    // Mouse movement disables keyboard mode (hybrid navigation)
    document.getElementById('list-container').addEventListener('mousemove', () => {
      if (keyboardMode) {
        keyboardMode = false;
        updateList();
      }
    });

    // Edit button click handler (event delegation)
    document.getElementById('list-container').addEventListener('click', (e) => {
      if (e.target.classList.contains('edit-btn')) {
        e.stopPropagation();
        const section = e.target.dataset.section;
        const index = parseInt(e.target.dataset.index, 10);

        if (section === 'objectives') {
          selectedIndex = index;
          startEdit();
        } else if (section === 'priorities') {
          promptTargetSection = 'priorities';
          promptTargetIndex = index;
          startEdit();
        }
      }
    });

    // Initialize
    async function init() {
      await showIntro();
      showObjectives();
    }

    init();
  </script>
</body>
</html>
